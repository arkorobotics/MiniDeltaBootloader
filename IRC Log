13:24 < arko> yo yo
13:24 < arko> adamgreig: around?
13:24 < adamgreig> ahoy
13:25 < arko> so i gotta stm32 bootloader question for you
13:25 < arko> rather.. memory mapping and things
13:25 < adamgreig> shoot
13:26 < arko> so i got this monoprice 3d printer
13:26 < adamgreig> (the onboard bootloader it ships with, or a custom one?)
13:26 < arko> i *think* its custom
13:26 < arko> so
13:26 < arko> maybe
13:26 < arko> anyway, i got this printer, attempted to load it with the latest firmware via sd
13:27 < arko> and it failed halfway through
13:27 < arko> and now it's not working
13:27 < adamgreig> ugh
13:27 < arko> so i opened it up, attempted to load the bin file they posted to 0x0800_0000
13:27 < arko> no luck
13:27 < adamgreig> the file they posted is just a raw .bin?
13:27 < arko> so i bought another one, opened it up and attempted to extract the firmware
13:28 < arko> but it has read protection enabled
13:28 < arko> yes, raw bin
13:28 < adamgreig> if the chip has a bootloader on it, then odds are their bootloader lives at 0x0800_0000 and the application binary lives later on
13:28 < arko> (i saw your reply to scanlime, and figured you're the perfect person to talk to)
13:28 < arko> yeah
13:28 < adamgreig> but the chip should start execution from the reset vector at 0x0800_0000 anyway so if you did load there it should work...
13:28 < arko> exactly
13:28 < arko> because their firmware update was via sd card
13:28 < arko> which i dont believe is standard with the series
13:29 < adamgreig> do you know precisely what chip it is?
13:29 < arko> rather, the default boot
13:29 < adamgreig> the stock bootloader does not support sd cards
13:29 < adamgreig> so yes, any sd card bootloader must be a custom one
13:29 < adamgreig> and how did you attempt to load the bin yourself? could you get at a jtag/swd port?
13:30 < adamgreig> there's a bunch of good vulnerabilities for removing code readout these days but probably easier to just try and ensure their bin is correctly flashed to the right place and that should be enough :P
13:30 < arko> yeah, it's a stm32f070
13:31 < arko> st-linkv2
13:31 < arko> the board has a debug port
13:31 < arko> almost wanted to get a chipwhisperer
13:31 < arko> and learn how to do firmware extraction
13:31 < adamgreig> yea i'm very tempted
13:32 < arko> anyway, i tried loading to various address locations
13:32 < arko> going by page offsets
13:32 < arko> but no luck
13:32 < adamgreig> since you have jtag access it can't be in the top security level
13:32 < adamgreig> so I guess you can now read back to check it's written right, and debug at your leisure?
13:32 < adamgreig> specifically if you set a break right at the start and single step you should see if it's running your new binary
13:33 < arko> hmm
13:33 < arko> yeah, tried that
13:33 < arko> it just crashes
13:33 < adamgreig> ok
13:33 < arko> goes to some sram address and hangs
13:33 < adamgreig> i suspect the binary image you have has a bunch of function pointers that only work when it's loaded to the exact right place
13:33 < arko> yea
13:33 < adamgreig> eg the whole vector table
13:34 < arko> yep, i suspected that to be the case
13:34 < arko> i disassembled it even
13:34 < adamgreig> so hopefully if you can find the right load address you're set
13:34 < arko> but i cant really interprit it well
13:34 < adamgreig> is the bin available for download?
13:34 < arko> yeah, but it doesnt seem easy
13:34 < arko> yeah, one sec
13:34 < arko> https://www.reddit.com/r/MPSelectMiniOwners/comments/7rvdu5/does_anyone_have_the_v37_firmware_for_the_mini/
13:35 < arko> ^ my poorly written reddit post
13:35 < arko> https://www.mpminidelta.com/firmware/motion_controller
13:35 < arko> green text box has version 41
13:36 < adamgreig> do you want 41 or 37?
13:36 < arko> 41
13:36 < arko> 37 has bugs :/
13:37 < arko> bad ones too.. like "lets randomly crash into the printer bed
13:37 < arko> , lulz, fuck you"
13:37 < adamgreig> lol
13:37 < adamgreig> what's the .flg file?
13:38 < arko> hmmm
13:38 < arko> oh
13:38 < arko> i think its a config file the bootloader looks for
13:38 < arko> if it sees that file, it loads the new firmware
13:38 < arko> or something like that
13:38 < arko> i wonder if that has the offset....
13:39 < adamgreig> lmao it's a text file
13:40 < arko> yeah
13:40 < arko> the message is great too
13:40 < arko> haha
13:41 < arko> the asm i decompiled seems to reference hard addresses
13:41 < arko> hard coded*
13:42 < adamgreig> the vector table at the start definitely has the right vectors in the right places so the whole thing does appear to be a regular firmware image
13:42 < arko> hmmm
13:42 < adamgreig> the reset vector is at 080171F5
13:43 < adamgreig> hmmm
13:43 < adamgreig> let's see
13:43 < arko> im curious to know how you determined that (this is the first time i've really tried to reverse something)
13:44 < adamgreig> first function is at office 0xC0 into the file and seems likely to be a real function
13:44 < adamgreig> wonder if it's one of the vectors
13:45 < adamgreig> so if you have the stm32f0 ref manual (RM0360) go to page 170 for the vector table
13:45 < adamgreig> the vector table is the first thing, it says that address 0x4 should have the reset vector, which is a u32 in little endian
13:45 < adamgreig> so at the very start of the bin, skip first four bytes ('reserved'), next four are 0xF5 71 01 08, which is 080171F5 in LE, which is a pointer into flash
13:46 < adamgreig> the vectors go up to 0xBC into the file, and sure enough the four bytes at 0xBC are another pointer into 0x08xxxxxx
13:46 < adamgreig> but right after that at 0xC0 is something else, and if you disassemble thumb2 from 0xC1 (note LSb set 1 for thumb2 mode) you get a convincing function that calls a bunch of other functions that gets you started on a call tree
13:47 < arko> oooooo
13:47 < adamgreig> so we have a function that lives at 0xC0, if that's one of the functions pointed to by the vectors (not guaranteed but maybe) we can work out its absolute address
13:48 < adamgreig> (note a bunch of branch instructions will be relative addressing so still work, whereas others will be absolute but by first loading an address into a pointer then jumping to it, those won't get analysed right away)
13:49 < adamgreig> so if we open the bin in ghex or something and look at the first bunch of u32 pointers, find the smallest one...
13:50 < arko> ohhhhh
13:51 < arko> oh man, i need some time to digest this
13:51 < adamgreig> this is where an stm32-aware decompiler could automatically tag all the vector table as functions, but since we don't know the load address that wouldn't work
13:51 < arko> i totally get what you're saying tho
13:52 < arko> yeah
13:53 < adamgreig> the lowest vector is 0x080095F9 and that's SysTick
13:53 < adamgreig> sadly the function at 0xC0 doesn't seem to be a systick handler lol
13:54 < adamgreig> but maybe it is, in which case 0x0800_95F9 would be 0xC0 in our file, which means the load address is 0x08009538
13:54 < adamgreig> (note the ...F9 function pointer has LSb set 1 because it's thumb2, but the real address of the function is ...F8)
13:57 < arko> huh??
13:57 < arko> why is that done?
13:57 < arko> the lsb set to 1
13:57 < adamgreig> in ARM, if you branch to an even address, it's interpreted as ARM assembly, and an odd address is thumb2
13:58 < adamgreig> but since all instructions must be at least 16 bit aligned, the lowest bit is never actually used for the address
13:58 < adamgreig> so it's ok to use it to signal the instruction type
13:58 < arko> owah
13:58 < arko> woah*
13:58 < adamgreig> hence you could interwork ARM and thumb2 in the same binary, swapping at runtime
13:58 < arko> :O
13:58 < adamgreig> cortex-m* doesn't support that though, they only execute thumb2
13:58 < adamgreig> but other/older ARMs did ARM as well as thumb2
13:59 < adamgreig> so all function calls on cortex-m will be to an odd address, but the function really starts at the byte before that
14:00 < adamgreig> anyway yea there's a slim chance the function at 0xC0 in this file is the SysTick handler, in which case it needs to live at 0x0800_95F8 and so the whole binary has a load address of 0x0800_9538
14:00 < adamgreig> but that doesn't seem very nice numerically does it
14:00 < adamgreig> you'd imagine they reserve a nice even number for the bootloader
14:00 < arko> lol right?
14:00 < arko> lets try it
14:00 < arko> yolo
14:00 < adamgreig> they might not - they might have finished the bootloader, measured its size, determined that was fine, and gone with it
14:01 < arko> yeah
14:01 < arko> seems likely
14:01 < adamgreig> the other thing you could try is if you can debug access the working one, you could break at the reset vector and step until it leaves the bootloader and see where it ends up
14:01 < adamgreig> otherwise you can analyse this binary further to try and work out where systick or reset or something is
14:01 < adamgreig> if you could identify the reset vector or the hardfault vector or something, you know what all their real addresses are
14:02 < adamgreig> so just go through all the functions early on in the file til one looks plausibly like a reset handler or whatever
14:02 < arko> oh shit
14:02 < arko> that's genius
14:03 < arko> i'm literally going to copy and paste this conversation into my log file
14:03 < adamgreig> it's not trivial in general to precisely identify where a function is though, or work out what it's doing
14:03 < adamgreig> usually you can go the other way
14:03 < adamgreig> you use the vector table to point you at the reset handler and can follow execution from there
14:03 < adamgreig> well that's what i usually do anyway :P
14:05 < LeoBodnar> ahoy arko
14:06 < arko> dude, thank you
14:06 < arko> seriously
14:06 < arko> i owe you a beer at least (even if i cant get this to work :P)
14:06 < arko> LeoBodnar: yo yo!
14:06 < LeoBodnar> have you been mourning successful heavy launch?
14:07 < arko> lol huh?
14:07 < arko> why mourn?
14:07 < LeoBodnar> nvm lol
14:07 < arko> im stoked
14:07 < LeoBodnar> i thought there is healthy rivalry
14:07 < arko> well, they keep stealing our people
14:08 < arko> thats about the only rivalry
14:08 < arko> they build the vehicles
14:08 < arko> we build the payloads ;)
14:08 < arko> unless your talking about NASA NASA
14:08 < arko> with SLS
14:08 < arko> more like NASA Boeing
14:09 < arko> im bored of mars tbh
14:09 < arko> europa is way cooler
14:09 < arko> literally!
14:09 < arko> anyway, im stoked they had a good flight
14:09 < arko> reuseable tech is the future
14:09 < arko> more vehicles, more competition is good
14:10 < LeoBodnar> i think M-23 M-33 started reusing LSB for security stuff
14:10 < arko> i want to see better/more frequent flight opportunities
14:10 < LeoBodnar> but, generally, if you know where LSB=1 is coming from you should have a grey beard
14:15 < LeoBodnar> are you writing your own ARM BL arko ?
14:19 < LeoBodnar> nvm read scrollback
14:20 < LeoBodnar> i am going to try a few Renesas Cortex-M4s
14:22 < adamgreig> anything good on them?
14:30 < adamgreig> hmm a lot of the vectors are just two bytes off from each other, there's 08017171, ..73, ..75, ..77, ..79
14:30 < adamgreig> wonder how that works
14:39 < LeoBodnar> have you disassembled the whole thing yet?
14:39 < adamgreig> hard to do a complete disassembly without knowing where the entry point is
14:40 < LeoBodnar> can you spill the bins?
14:40 < adamgreig> https://www.mpminidelta.com/_media/wiki/firmware/motion/mpmd_-_motion_v41_-_20170815_-_firmware.zip
14:40 < LeoBodnar> i can have a look if this helps
14:40 < adamgreig> sure
14:41 < adamgreig> the vector table is http://dpaste.com/2HVK16J
14:41 < adamgreig> so the game is just try and find a function that is probably one of those, or otherwise work out the load address of this binary
14:41 < LeoBodnar> so what is this? a bootloader or main code?
14:41 < adamgreig> main code
14:41 < adamgreig> we don't have the bootloader
14:42 < adamgreig> but the chip has a bootloader, and we don't know what address it tries to load code to / jump to
14:42 < LeoBodnar> and you are looking for the entry point?
14:42 < adamgreig> looking to work out what address this binary should be flashed to the stm32
14:42 < adamgreig> arko: if you've already flashed this binary to 0x0800_0000 you'll need to write your own bootloader to re-flash there which just jumps into this code
14:43 < adamgreig> (which also means if you've subsequently tried to load this to other addresses those definitely wouldn't have worked, since it'd still try starting at 0x0800_0000)
14:43 < adamgreig> "bootloader" - you just need a vector table and a few instructions to remap the vector table to the binary and jump to it
14:53 < LeoBodnar> this code needs to be loaded at 0x08002000
14:55 < LeoBodnar> arko: ^
14:56 < arko> funny you say that
14:56 < arko> i tried that a while back and the fan start to spin
14:56 < arko> but it wouldnt communicate
14:56 < arko> and would get stuck at some address (i forget)
15:02 < LeoBodnar> how are you starting this?
15:05 < adamgreig> LeoBodnar: it's believable but how do you get 0x08002000?
15:05 < LeoBodnar> looked lol
15:06 < adamgreig> arko: if you tried 0x08000000 first you'd have overwritten whatever original bootloader jumped to 08002000
15:08 < arko> yeah
15:08 < arko> i have
15:08 < arko> i was afraid of that
15:08 < arko> blah
15:08 < arko> looks like i have no other choice but to write a bootloader
15:08 < LeoBodnar> https://www.irccloud.com/pastebin/wDOjr8A7/
15:09 < arko> https://jcastellssala.com/2016/12/15/cortex-m0-boot/
15:09 < arko> LeoBodnar: what did you use to decompile?
15:10 < LeoBodnar> unless BL sets up some TCM and other crap you just need to load stack pointer and jump to 080171F4
15:10 < arko> adamgreig: that bootloader page seems really helpful
15:10 < arko> i got some homework to do
15:10 < arko> lol, you guys are helping faster than i can keep up
15:10 < LeoBodnar> IDA ofc
15:11 < arko> im also trying to document to write this up
15:11 < LeoBodnar> this is not M0+ is it?
15:11 < adamgreig> LeoBodnar: won't you need to remap vector table too?
15:12 < LeoBodnar> sure, or copy this over existing one
15:12 < adamgreig> sure
15:13 < LeoBodnar> lol i am looking at my BL and can't figure out what it does
15:15 < arko> LOL
15:15 < LeoBodnar> https://www.irccloud.com/pastebin/YvGkeH00/
15:16 < LeoBodnar> basically just three steps, after // application code present
15:16 < adamgreig> looks like you remap the vector table as normal
15:16 < adamgreig> yea
15:16 < LeoBodnar> i wish I stole this from someone so I could go and plea for help
15:19 < adamgreig> the vector remapping is just that write to VTOR, it's on pg B3-267 of the ARMv6-M ARM
15:19 < LeoBodnar> yep
15:20 < adamgreig> still don't see where you get 0x0800_2000 from unless IDA just guesses and tells you
15:20 < LeoBodnar> lol it's simple
15:21 < LeoBodnar> if you load it at 08000000 then 080171F4 outside the code
15:21 < LeoBodnar> so it has to load higher
15:22 < LeoBodnar> startup is usually is near the end or beginning
15:22 < adamgreig> mmm okay
15:22 < adamgreig> I didn't consider reset being the final function
15:22 < Darkside> hrm
15:22 < adamgreig> but yea I see, since reset clearly isn't at the start, if you assume it's the final function then only that load address makes sense of everything
15:22 < adamgreig> fair
15:23 < LeoBodnar> assuming it's near the beginning you'd have to load it at 08010000 which invalidates a lot of other 0800xxxx addresses
15:23 < adamgreig> certainly once I load the segment there I manage to pick up all the other functions and disassemble okay
15:23 < adamgreig> yea
15:23 < adamgreig> hypothethically it could have been something less numerically convenient and you still basically have to guess on heuristics, but once you get it right it's fairly quick to confirm it matches up with all the numbers you do have
15:24 < adamgreig> not like it has to line up with flash pages etc, just it's way more convenient if it does so it probably does...
15:24 < LeoBodnar> programmers are simple creatures, they don't like allocating stuff from scary boundaries
15:25 < LeoBodnar> and does make sense to stick to flash pages
15:25 < adamgreig> i was expecting most vectors to be near the start and didn't really consider that if reset wasn't near the start it might be right at the end
15:25 < adamgreig> yea sure, means you can flash bootloader separaetly to main img etc
15:25 < adamgreig> and of course if the user code is on the same page as bootloader...
15:25 < adamgreig> ...you'll struggle to write new user code from the bootloader
15:25 < LeoBodnar> you often want to have a page ofr random stuff like eeprom emulation, erial numbers, cal constants, etc
15:25 < adamgreig> also the whole length of the code should have been a clue compared to the reset vector
15:25 < adamgreig> yea
15:26 < LeoBodnar> which makes it either last page of flash or one below main code
15:27 < LeoBodnar> M0+ does not have relocateable VTOL does it?
15:27 < LeoBodnar> i have never used M0 or M0+
15:28 < LeoBodnar> *VTOR
15:29 < adamgreig> ARMv6-M has relocatable VTOR generally, but the CM0 TRM doesn't mention it
15:31 < adamgreig> yea, ok, the cortex-m0+ generic user guide says vtor exists if implemented
15:32 < adamgreig> but the ST programmer's manual for STM32F0 does not mention VTOR
15:33 < adamgreig> I think cm0+ does and cm0 doesn't
15:33 < LeoBodnar> makes bootloading a bit awkward (and simpler at the same time)
15:33 < adamgreig> anyway you can instead make a new vtable in ram at 0x2000_0000 and then there's a different bit you can set to map ram to 0x0000_0000
15:33 < LeoBodnar> dynamically?
15:34 < LeoBodnar> ofc
15:34 < LeoBodnar> soilly question
15:34 < adamgreig> yea
15:34 < adamgreig> by default flash is mapped to 0x0
15:34 < Darkside> hrm
15:34 < LeoBodnar> otherwise you are locked out forever trying to boot from uninited ram
15:34 < Darkside> in a few months i might be needing to reverse engineer some stm32 firmware..
15:35 < Darkside> or at least bits of it (how the IOs on a particular board are configured mainly)
15:35 < Darkside> i figure that much should be easy enough to figure out?
15:35 < LeoBodnar> reasonably trivial
15:35 < LeoBodnar> if you have the binary
15:36 < adamgreig> SYSCFG_CFGR1 MEM_MODE bits 0:1 do it, x0 for flash, 01 for system flash, 11 for sram
15:36 < Darkside> LeoBodnar: yeah getting the binary will be the fun bit
15:37 < Darkside> the chip has read lock on
15:37 < adamgreig> so yea you copy vtable from 0x0800_2000 into 0x2000_0000 and then set SYSCFG_CFGR1 |= 3
15:37 < Darkside> but there are ways around that
15:37 < adamgreig> and then you're in business
15:37 < arko> im so lost
15:37 < arko> hahaha
15:38 < adamgreig> arko: that bootloader page you linked to covers it all
15:38 < adamgreig> you need a quick simple bootloader, like the demo one on that page (or something more DIY that doesn't use ST's gross macros lol)
15:38 < arko> cool, im gonna follow that and try
15:38 < arko> then come back here once i know a bit more ;)
15:38 < adamgreig> your bin needs to be flashed at 0x0800_2000 and your own bootloader at 0x0800_0000
15:38 < LeoBodnar> what are you guys doing? unbricking something?
15:38 < fsphil> what's the device?
15:39 < adamgreig> then your bootloader needs a normal vector table and a main function that copies the first 0xc0 bytes from 0x0800_2000 into 0x2000_0000 and then sets the bottom two bits of SYSCFG_CFGR1
15:39 < adamgreig> (the latter action tells the stm32 to map ram to address 0x0 so that the vtable can live in ram)
15:39 < Darkside> fsphil: the plan is to dump the firmware from a RS41 and figure out how it drives the sensors
15:39 < adamgreig> fsphil: stm32f070 on a https://www.mpminidelta.com/firmware/motion_controller
15:39 < LeoBodnar> it's probably healthier for interrupts latency anyway
15:39 < Darkside> two different projects going on here
15:39 < Darkside> :P
15:40 < adamgreig> LeoBodnar: yea unbricking from failed update
15:40 < adamgreig> and then from writing the .bin over the existing bootloader :P
15:40 < LeoBodnar> so you have wiped out original BL i assume?
15:40 < fsphil> it's all stm32 all the way down
15:41 < LeoBodnar> j-link allows reading any ROM/RAM area if IC is not protected
